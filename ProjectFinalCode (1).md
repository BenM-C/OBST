For this set of code, there aren't many packages that do much heavy lifting.  Numpy is used for easier three-dimensional array manipulation in calculating the OBST.  Sys is used simply for the purpose of the maximal integer and could be done with an arbitrary value.  Deque is used to save time implementing a double ended queue for the BFS.  
\
The only package that does any heavy lifting is the [binarytree](https://pypi.org/project/binarytree/) package which contains a function build, that can easily visualize a binary search tree by iteratively building it form an array.  


```python
import numpy as np
import sys
from collections import deque
from binarytree import bst, build
```

This is the primary section of code used to generate an optimal binary search tree.  Given two list paramaters, $p$ and $q$.  The list $p$ corresponds to the frequencies of searching for each node, and $q$ coresponds to the frequencies of searching for nodes that are not present but fall between each $p$ node which are grouped into a single null node.  These nodes are ordered.  See the example containing 4 nodes, and 5 null nodes would be as follows:

$$q_0,M_1,q_1, M_2, q_2, M_3, q_3, M_4,q_4$$

The function **OBST** takes in these parameters and returns a binary search tree.  This is piggy backed off of a custom binary search tree class I cooked up and included below.  
\
\
**OBST** is designed with two helper functions.  The first is **calc_OBST** which implements the dynamic programing solution we discussed in class and is presented in CLRS.  This dynamic programing problem and its solution are as follows:

**Sub-Problem:**

The optimal tree containing the nodes $i$ through $j$, denoted $T_{i,j}$.  This can be found at index $(

**Base Case**

**Recursion**

**Explaination**

**Run-Time**

The next helper function is **OBST_constructor** which takes the root array generated by **calc_OBST** and reconstructs the optimal BST in an instance of the custom class **BST**.  


```python
def OBST(p,q):
    '''
    Optimal Binary search trees
    ==================
    Arguments:
    
        P:   List, np.ndarray--coresponding the probabilites a node is visited

        M:   List, np.ndarray--coresponding the probabilites of null nodes, size |p|+1
    
    Returns:
    
        tree:   BST--instance of a binaary search tree object coresponding to custom class BST
    '''
    def calc_OBST(p,q,n):
        '''
        calculates the optimal solution for a binary search tree using dynamic programing
        ==================
        Arguments:

            P:   List, np.ndarray--coresponding the probabilites a node is visited

            M:   List, np.ndarray--coresponding the probabilites of null nodes, size |p|+1
            
            n:   number of nodes--analagous to len(p)

        Returns:

            dp:   np.ndarray--3 dimensional array of size (3,n+1,n+1), indexing (depth, row, col). dp[0::] coresponds
                  to the weights of tree(i,i+j),dp[1::] coresponds to the cost of tree(i,i+j), and dp[2::] coresponds
                  to the root of tree(i,i+j). 
        '''
        dp = np.zeros((3,n+1,n+1))#z index: 0=w, 1=c 2 = r
        dp[:,:,:],dp[1,0,:]= None,0 #set initial costs to 0, else NaN
        for i in range(n+1): #initialize first row/base case of no elements with weights
            dp[0,0,i] = q[i]
        for j in range(1,n+1): #number of movies
            for i in range(n-j+1): #starting where
                dp[0,j,i]= dp[0,j-1,i]+p[i+j-1]+q[i+j]
                dp[1,j,i] = sys.maxsize
                for k in range(i+1,i+j+1):
                    t = dp[0,j,i]+dp[1,k-1-i,i]+dp[1,i+j-k,k]
                    if t< dp[1,j,i]:
                        dp[1,j,i] = t
                        dp[2,j,i] = k
        return dp
    
    def OBST_constructor(A,i,j):
        '''
        based on the DP array of roots of each subtree T(i,j+i), this reconstructs a BST
        ==================
        Arguments:

            A:   (n+1,n+1)np.ndarray--coresponding roots of each optimal sub-tree

            i,j: int-- coresponding to the start location in the DP array of the sub-tree containing all nodes, 
                 typically, (0, len(p))

        Returns:

            st:   BST object--Custom BST class containing the optimal binary search tree
            
        Note: this is not designed to include the null nodes in the tree coresponding to q as they are implied
              by the ordering of the nodes...ie q0 needs to be the left child of p1.  
        '''
        #establish root from A and check if it is a null node.  
        r = A[j-i,i]
        if np.isnan(r):
            return None
        #if if the root is another node, recursively call OBST_constructor on each of its children to get the optimal
        #sub trees and construct a new tree with the value of root, and its two optimal sub-trees
        else:
            st = myBST(value = int(r))
            st.left = OBST_constructor(A,i,int(r)-1)
            st.right = OBST_constructor(A,int(r), j)
            return st
    
    ##################################################################
    #if p and q are the right length use helper functions to return the obst
    if len(q) == len(p)+1:
        dp = calc_OBST(p,q,len(p))
        tree = OBST_constructor(dp[2,:,:],0,len(p))
        return tree
    else:
        print('incorrrect number of nodes')
    
```


```python
#testing examples! taken from the homework to show that this method works.  
#Movies
p=[2,1,4,1]
q = [1,2,1,1,3]
#homework
m = [5,3,2,1]
d = [5,1,1,1,1]
tree1 = OBST(p,q)
tree2 = OBST(m,d)
tree1.visualize(), tree2.visualize()
```

The following portion of the code is mostly designed for the visualization of the OBST once it is calculated.  It contains several class methods that are not necessary for 


```python
class BST:
    '''
    Custom Binary search tree class
    ==================
    Arguments:
    
        P:   List, np.ndarray--coresponding the probabilites a node is visited

        M:   List, np.ndarray--coresponding the probabilites of null nodes, size |p|+1
    
    Returns:
    '''
        
    def __init__(self, value = None,left = None, right = None):
        '''
        Each tree contains three atributes, a value and a pointer to left and right child 
        all initialized to None, meaning an empty tree can exist
        '''
        self.left = left
        self.right = right
        self.value = value
            
    def stats(self):
        '''
        basic to_string option
        '''
        print('Tree with root: ', self.value, 'containing', len(self.inorderTraversal()), 'nodes with a maximum depth of: ', self.maxDepth())
        
    def insert_1(self,v):
        '''
        Inserts a single value into BST
        checks if the value of the root is none and if not insert_1 recursively into the right or left sub-tree
        ==================
        Arguments:
    
            v:   int, float--a singular value to be inserted into itself BST
    
        Returns: None
        '''
        if self.value!=None:
            if v < self.value:
                if self.left is None:
                    self.left = BST(value = v)
                else:
                    self.left.insert_1(v)
                    
            elif v > self.value:
                if self.right is None:
                    self.right = BST(value = v)
                else:
                    self.right.insert_1(v)
            else:
                self.value = v
        else:
            self.value = v
                    
    def insert(self,data):
        '''
        Inserts a single, or an array-like set of values into BST
        checks the type, and calls insert_1
        ==================
        Arguments:
    
            data:   int, float, list, np.ndarray--value(s) to be inserted into tree
    
        Returns: None
        '''
        if isinstance(data,(str,int,float)):
            self.insert_1(data)
        elif isinstance(data, (np.ndarray,list)):
            for i in data:
                self.insert_1(i)
        else:
            raise TypeError
        self.depth = self.maxDepth()
        self.size = len(self.inorderTraversal())
            
    def maxDepth(self):
        '''
        calculates the maximum depth for the tree, implemented to find the maximum number of iterations on BFS
        ==================
        Arguments:
            
            self--BST
    
        Returns: 
            
            int--maximum depth of the tree
        '''
        if self.value==None:
            return 0
        else:
            try:
                leftDepth = self.left.maxDepth()
            except:
                leftDepth = 0
            try:
                rightDepth = self.right.maxDepth()
            except:
                rightDepth = 0
            if leftDepth > rightDepth:
                return leftDepth + 1
            else:
                return rightDepth + 1

    def BFS(self, filtered = True):
        BFS = []
        if np.isnan(self.value):
            return None
        q = deque()
        q.append(self)
        i=0
        while i<2**self.maxDepth():
            n = q.popleft()
            BFS.append(n.value)
            if n.left!=None:
                q.append(n.left)
            else: q.append(BST())
            if n.right!=None:
                q.append(n.right)
            else: q.append(BST())
            i+=1
                
                
        if filtered:
            return list(filter(None,BFS))
        else: 
            return BFS
    
    def inorderTraversal(self, p = True):
        l = []
        if self.left:
            l = l+self.left.inorderTraversal()
        l.append(self.value)
        if self.right:
            l=l+self.right.inorderTraversal()
        if p:
            return l
        else:
            return l
    
    def visualize(self):
        print(build(self.BFS(filtered = False)))    
        
    def search(self, key):
        '''
        maybe i'll implement this one day
        '''
        return None
    
```
